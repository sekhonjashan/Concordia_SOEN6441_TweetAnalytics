
package controllers;

import play.data.Form;
import play.data.FormFactory;

import play.libs.oauth.OAuth.RequestToken;
import play.libs.ws.WSClient;
import play.libs.concurrent.HttpExecutionContext;

import play.mvc.Controller;
import play.mvc.Result;

import service.TwitterOAuth;
import service.TwitterService;
import service.TwitterServiceImpl;

import util.JsonHelper;
import util.SessionUtils;

import com.fasterxml.jackson.databind.JsonNode;

import com.google.common.base.Strings;

import models.Tweet;

import views.html.tweets;

import javax.inject.Inject;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * <h1> Twitter Analytics !</h1> 
 * Twitter Analytics implements an application that simply searches the 
 * tweets for a specific keyword and displays it on the result screen.
 * If another search is made tweets are added to the same result page accordingly.
 * Application allows to navigate to the user's profile and displays basic information
 * about the tweet user.
 * Also, on the profile page latest 10 tweets are displayed.
 * Application is build using play framework 2.6. 
 * 
 * <p>
 * <b>NOTE:</b> Application uses twitter normal search API , which allows only tweets
 * search in past week only.
 * 
 * @author Jashan Singh.
 * 
 * @version V1
 * @since V_1.1
 * 
 * Class constructor 
 * {@code #Twitter(WSClient, FormFactory, HttpExecutionContext)Twitter}
 * 
 *  
 */
public class Twitter extends Controller {

	private final FormFactory formFactory;
	private final WSClient ws;
	private HttpExecutionContext ec;
	@Inject TwitterService serviceImpl;
	
	/**
	 * Constructor
	 * @param ws - an interface for the {@link WSClient} web service client connection. 
	 * @param formFactory
	 * @param ec
	 * 
	 */
	@Inject
	public Twitter(WSClient ws, FormFactory formFactory, HttpExecutionContext ec) {
		this.ws = ws;
		this.formFactory = formFactory;
		this.ec = ec;
	}

	/**
	 * 	
	 * @return Renders index HTML page 
	 */
	public Result index() {
		JsonHelper.recentSearchTweets = new ArrayList<Map<String, JsonNode>>();
		return ok(views.html.index.render());
	}
	
	/**
	 * Maps the results based on the keyword and creates the form. 
	 * @return tweets mapped
	 */
	public Result tweets() {
		List<Map<String, JsonNode>>  list = new ArrayList<Map<String, JsonNode>>();
		Form<Tweet> form = formFactory.form(Tweet.class);
		List<String> keywords = new ArrayList<String>();
		return ok(tweets.render(list, form , keywords));
	}

	/**
	 * Performs the authentication procedure with Twitter Service Provider using the
	 * OAUTH authentication principle. 
	 * Uses a 2 step approach.
	 * <p>
	 * This Consumer Key (request/secret) token is saved in the HTTP Session
	 * Object. Verifier token gets generated by the Service Provider and
	 * retrieved through the callback URL.
	 * </p>
	 * <p>
	 * Uses the verifier token and generates an access token.
	 * </p>
	 * Redirects this action to the welcome page.
	 * 
	 * {@code service.TwitterOAuth}
	 * @return {@code Result}
	 */
	public Result auth() {
		String verifier = request().getQueryString("oauth_verifier");
		TwitterOAuth twitterOAuth = TwitterOAuth.getInstance();

		if (Strings.isNullOrEmpty(verifier)) {

			String callbackUrl = routes.Twitter.auth().absoluteURL(request());
			RequestToken requestToken = twitterOAuth.getRequestToken(callbackUrl);
			SessionUtils.saveKeys(session(), requestToken.token, requestToken.secret);

			return redirect(twitterOAuth.getOAuth().redirectUrl(requestToken.token));

		} else {

			String token = SessionUtils.getToken(session());
			String secret = SessionUtils.getSecret(session());
			RequestToken requestToken = twitterOAuth.getAccessToken(verifier, token, secret);
			SessionUtils.saveKeys(session(), requestToken.token, requestToken.secret);

			return redirect(routes.TwitterController.sandbox()); //uncomment for latest version with actors.
			//return redirect(routes.Twitter.tweets()); //uncomment for previous version
		}
	}

	/**
	 * Validates the Session and gets the HomeTimeLine from the Twitter Service
	 * Provider uses this access tokens.
	 * 
	 * @return {@code CompletionStage<Result>}
	 */
	public CompletionStage<Result> homeTimeline() {

//		if (SessionUtils.isSessionActive(session())) {
//			String token = SessionUtils.getToken(session());
//			String secret = SessionUtils.getSecret(session());
//			serviceImpl.getHomeTimeLineAsync(ws, token, secret).thenApply(fn -> ok(fn));
//		}

		return CompletableFuture.completedFuture(redirect(routes.Twitter.auth()));
	}

	/**
	 * Searches the tweets based on the keywords.
	 * 
	 * @param hastag - String for the searching element.
	 * @return {@code CompletionStage<Result>}
	 */
	public CompletionStage<Result> getTweets(String hastag) {

		String token = SessionUtils.getToken(session());
		String secret = SessionUtils.getSecret(session());
		hastag= hastag.replace("#", "%23");

		return serviceImpl.getTweetsAsync(ws, hastag, token, secret).thenApplyAsync(
				fn -> ok(views.html.tweets.render(JsonHelper.groupByText(fn), formFactory.form(Tweet.class) , JsonHelper.searchKeyword)),
				ec.current());

	}

	/**
	 * Gets the user timeline based on the user profile identifier.
	 * 
	 * @param tag - String identifier of user profile.
	 * @return {@code CompletionStage<Result>}
	 */
	public CompletionStage<Result> userTimeline(String tag) {

		String token = SessionUtils.getToken(session());
		String secret = SessionUtils.getSecret(session());
		return serviceImpl.getUserTimelineAsync(ws, tag, token, secret).thenApply(fn -> formatJsonNode(fn));
	}

	/**
	 * Parses the JsonNode element to remove the User Profile information and
	 * renders the Profile View using the retrieved information using {@code Map} 
	 * 
	 * @param rootNode - JsonNode representing response from the HTTP GET Service Request
	 * @return {@code Result}
	 */
	private Result formatJsonNode(JsonNode rootNode) {

		return ok(views.html.profile.render(JsonHelper.groupByProfileImage(rootNode),
				JsonHelper.groupByLocDesc(rootNode), JsonHelper.groupByCreatedAt(rootNode)));
	}

	/**
	 * Searches the tweets for a given search element. 
	 * Retrieves the searched elements from the bean class Tweet.
	 *  
	 * @code {@getTweets(String keyword)}
	 * @return {@code Result}
	 */
	public Result searchTweets() {
		Form<Tweet> form = formFactory.form(Tweet.class);
		final Form<Tweet> boundForm = form.bindFromRequest();
		Tweet data = boundForm.get();
		JsonHelper.searchKeyword.add(0 , data.name);
		return redirect(routes.Twitter.getTweets(data.name));
	}
}
